
#ifndef GETPOT_ERRORCONTROLLER_H
#define GETPOT_ERRORCONTROLLER_H

#include "Framework.h"
#include "PrimalSolver.h"
#include "DualSolver.h"

template <int dim>
class ErrorController : public PrimalSolver<dim>, public DualSolver<dim>
{
public:
    // CONSTRUCTOR
    ErrorController(
            Triangulation<dim> &                       coarse_grid,
            const FiniteElement<dim> &                     primal_fe,
            const FiniteElement<dim> &                     dual_fe,
            const Quadrature<dim> &                        quadrature,
            const Quadrature<dim - 1> &                    face_quadrature,
            const Function<dim> &                          rhs_function,
            const DualFunctionalBase<dim> &dual_functional);
    // Bdry values to be done in solvers
    using active_cell_iterator = typename DoFHandler<dim>::active_cell_iterator;
    // METHODS
    virtual void solve_problem() override;
    virtual unsigned int n_dofs() const override;
    virtual void refine_grid() override;
    //virtual void output_solution() const override;                // TO BE DONE

private:
    //
    // ... removed a lot of things
    //
    void estimate_error(Vector<float> &error_indicators) const;     // TO BE DONE
    double global_estimate() const;
    //
    // ... removed a lot of things
    //

    struct CellData
    {
        FEValues<dim>                           fe_values;
        const SmartPointer<const Function<dim>> right_hand_side;

        std::vector<double> cell_residual;
        std::vector<double> rhs_values;
        std::vector<double> dual_weights;
        std::vector<double> cell_laplacians;    //useless
        typename std::vector<Tensor<1, dim>> cell_primal_gradients;
        typename std::vector<Tensor<1, dim>> cell_dual_gradients;
        CellData(const SmartPointer<const FiniteElement<dim>> ptr_fe,
                 const SmartPointer<const Quadrature<dim>>   ptr_quadrature,
                 const SmartPointer<const Function<dim>>     ptr_right_hand_side);
        CellData(const CellData &cell_data);
    };
    void integrate_over_cell(
            const active_cell_iterator &cell,
            const Vector<double> &      primal_solution,
            const Vector<double> &      dual_weights,
            CellData &                  cell_data,
            Vector<float> &             error_indicators) const;
};

// CONSTRUCTOR
template <int dim>
ErrorController<dim>::ErrorController(
        Triangulation<dim> &                           coarse_grid_,
        const FiniteElement<dim> &                     primal_fe_,
        const FiniteElement<dim> &                     dual_fe_,
        const Quadrature<dim> &                        quadrature_,
        const Quadrature<dim - 1> &                    face_quadrature_,
        const Function<dim> &                          rhs_function_,        //  Not sure
        //const Function<dim> &                          bv,                  //  Not sure
        const DualFunctionalBase<dim> &dual_functional_      //  Not sure
)
        : Base<dim>(coarse_grid_)
        , PrimalSolver<dim>(coarse_grid_,
                            primal_fe_,
                            quadrature_,
                            face_quadrature_,
                            rhs_function_)
        , DualSolver<dim>(coarse_grid_,
                          dual_fe_,
                          quadrature_,
                          face_quadrature_,
                          dual_functional_)
{}

// CONSTRUCTOR CellData
template <int dim>
ErrorController<dim>::CellData::CellData(
        const SmartPointer<const FiniteElement<dim>> ptr_fe,
        const SmartPointer<const Quadrature<dim>>   ptr_quadrature,
        const SmartPointer<const Function<dim>>     ptr_right_hand_side)
        : fe_values(*ptr_fe,
                    *ptr_quadrature,
                    update_values | update_hessians | update_quadrature_points |
                    update_JxW_values)
        , right_hand_side(ptr_right_hand_side)
        , cell_residual(ptr_quadrature->size())
        , rhs_values(ptr_quadrature->size())
        , dual_weights(ptr_quadrature->size())
        , cell_laplacians(ptr_quadrature->size())
{
    cell_primal_gradients.resize(ptr_quadrature->size());
    cell_dual_gradients.resize(ptr_quadrature->size());
}

template <int dim>
ErrorController<dim>::CellData::CellData(const CellData &cell_data)
        : fe_values(cell_data.fe_values.get_fe(),
                    cell_data.fe_values.get_quadrature(),
                    update_values | update_hessians | update_quadrature_points |
                    update_JxW_values)
        , right_hand_side(cell_data.right_hand_side)
        , cell_residual(cell_data.cell_residual)
        , rhs_values(cell_data.rhs_values)
        , dual_weights(cell_data.dual_weights)
        , cell_laplacians(cell_data.cell_laplacians)
        , cell_primal_gradients(cell_data.cell_primal_gradients)
        , cell_dual_gradients(cell_data.cell_dual_gradients)

{}

template <int dim>
void ErrorController<dim>::solve_problem()
{
    this->PrimalSolver<dim>::solve_problem();
    this->DualSolver<dim>::solve_problem();
}

template <int dim>
unsigned int ErrorController<dim>::n_dofs() const
{
    return PrimalSolver<dim>::n_dofs();
}


template <int dim>
void ErrorController<dim>::refine_grid() {
    Vector<float> error_indicators(this->triangulation->n_active_cells());
    cout<<"   [ErrorController::refine_grid]Build vector to store errors"<<endl;
    estimate_error(error_indicators);
    cout<<"   [ErrorController::refine_grid]Estimate errors"<<endl;

    double global_error=0.0;
    global_error=global_estimate();
    double global_error_as_sum_of_cell_errors=0.0;
    for(size_t i=0;i<error_indicators.size();i++)
        global_error_as_sum_of_cell_errors+=error_indicators[i];
    cout<<"   [ErrorController::refine_grid]Global error = "<<global_error<<endl
        <<"   [ErrorController::refine_grid]Global error as sum of cells' errors = "<<global_error_as_sum_of_cell_errors<<endl;

    for (float &error_indicator : error_indicators)
        error_indicator = std::fabs(error_indicator);

    GridRefinement::refine_and_coarsen_fixed_fraction(*this->triangulation,
                                                      error_indicators,
                                                      0.8,
                                                      0.02);
    this->triangulation->execute_coarsening_and_refinement();
    cout<<"   [ErrorController::refine_grid]Executed coarsening and refinement"<<endl;
}

template <int dim>
void ErrorController<dim>::estimate_error(Vector<float> &error_indicators) const
{   // INTERPOLATION
    AffineConstraints<double> dual_hanging_node_constraints;
    DoFTools::make_hanging_node_constraints(DualSolver<dim>::dof_handler,
                                            dual_hanging_node_constraints);
    dual_hanging_node_constraints.close();
    Vector<double> primal_solution(DualSolver<dim>::dof_handler.n_dofs());
    cout<<"   Interpolated primal solution DOF "<<primal_solution.size()<< endl;
    FETools::interpolate(PrimalSolver<dim>::dof_handler,
                         PrimalSolver<dim>::solution,
                         DualSolver<dim>::dof_handler,
                         dual_hanging_node_constraints,
                         primal_solution);

    AffineConstraints<double> primal_hanging_node_constraints;
    DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,
                                            primal_hanging_node_constraints);
    primal_hanging_node_constraints.close();
    Vector<double> dual_weights(DualSolver<dim>::dof_handler.n_dofs());
    FETools::interpolation_difference(DualSolver<dim>::dof_handler,
                                      dual_hanging_node_constraints,
                                      DualSolver<dim>::solution,
                                      PrimalSolver<dim>::dof_handler,
                                      primal_hanging_node_constraints,
                                      dual_weights);
    cout<<"   [ErrorController::estimate_error]Interpolations done"<<endl;

    // Instance CELL DATA
    CellData cell_data(this->DualSolver<dim>::fe,
                       this->DualSolver<dim>::quadrature,
                       this->PrimalSolver<dim>::rhs_function);
    cout<<"   [ErrorController::estimate_error]Instantiated CellData"<<endl;

    // INTEGRATE OVER CELLS
    for (const auto &cell : DualSolver<dim>::dof_handler.active_cell_iterators()){
        integrate_over_cell(cell,
                            primal_solution,
                            dual_weights,
                            cell_data,
                            error_indicators);
    }

    for (const auto &cell : DualSolver<dim>::dof_handler.active_cell_iterators())
    {
      for (const auto &face_no : DualSolver<dim>::dof_handler.active_face_iterators())
      {
        //First, if this face is part of the boundary, then there is nothing to do. However, to make things easier when summing up the contributions of the faces of cells, we enter this face into the list of faces with a zero contribution to the error.

        if (cell->face(face_no)->at_boundary())
        {
            face_integrals[cell->face(face_no)] = 0;
            continue;
        }

        //Next, note that since we want to compute the jump terms on each face only once although we access it twice (if it is not at the boundary), we have to define some rules who is responsible for computing on a face:

        //First, if the neighboring cell is on the same level as this one, i.e. neither further refined not coarser, then the one with the lower index within this level does the work. In other words: if the other one has a lower index, then skip work on this face:

        if ((cell->neighbor(face_no)->has_children() == false) &&
            (cell->neighbor(face_no)->level() == cell->level()) &&
            (cell->neighbor(face_no)->index() < cell->index()))
            continue;

        //Likewise, we always work from the coarser cell if this and its neighbor differ in refinement. Thus, if the neighboring cell is less refined than the present one, then do nothing since we integrate over the subfaces when we visit the coarse cell.

        if (cell->at_boundary(face_no) == false)
            if (cell->neighbor(face_no)->level() < cell->level())
                continue;


        //Now we know that we are in charge here, so actually compute the face jump terms. If the face is a regular one, i.e. the other side's cell is neither coarser not finer than this cell, then call one function, and if the cell on the other side is further refined, then use another function. Note that the case that the cell on the other side is coarser cannot happen since we have decided above that we handle this case when we pass over that other cell.

        if (cell->face(face_no)->has_children() == false)
            integrate_over_regular_face(cell,
                                        face_no,
                                        scratch_data.primal_solution,
                                        scratch_data.dual_weights,
                                        scratch_data.face_data,
                                        face_integrals);
        else
            integrate_over_irregular_face(cell,
                                          face_no,
                                          scratch_data.primal_solution,
                                          scratch_data.dual_weights,
                                          scratch_data.face_data,
                                          face_integrals);
    }
}
    cout<<"   [ErrorController::estimate_error]Loop integral over cells done"<<endl;
}

template <int dim>
void ErrorController<dim>::integrate_over_cell(
        const active_cell_iterator &cell,
        const Vector<double> &      primal_solution,
        const Vector<double> &      dual_weights,
        CellData &                  cell_data,
        Vector<float> &             error_indicators) const
{
    cell_data.fe_values.reinit(cell);
    cell_data.right_hand_side->value_list(cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values);
    //cell_data.fe_values.get_function_gradients(primal_solution, cell_data.cell_primal_gradients);
    //cell_data.fe_values.get_function_gradients(dual_weights, cell_data.cell_dual_gradients);
    cell_data.fe_values.get_function_laplacians(primal_solution,
                                                cell_data.cell_laplacians);
    cell_data.fe_values.get_function_values(dual_weights,
                                            cell_data.dual_weights);


    double sum = 0;
    /*for (unsigned int p = 0; p < cell_data.fe_values.n_quadrature_points; ++p) {
        sum += (cell_data.cell_primal_gradients[p] *
                cell_data.cell_dual_gradients[p] * cell_data.fe_values.JxW(p)); */
    for (unsigned int p = 0; p < cell_data.fe_values.n_quadrature_points; ++p)
        sum += ((cell_data.rhs_values[p] + cell_data.cell_laplacians[p]) *
                cell_data.dual_weights[p] * cell_data.fe_values.JxW(p));
    error_indicators(cell->active_cell_index()) += (0 - sum);
}

template <int dim>
void ErrorController<dim>::integrate_over_regular_face(
        const active_cell_iterator &cell,
        const unsigned int          face_no,
        const Vector<double> &      primal_solution,
        const Vector<double> &      dual_weights,
        FaceData &                  face_data,
        FaceIntegrals &             face_integrals) const
{
    const unsigned int n_q_points =
            face_data.fe_face_values_cell.n_quadrature_points;

    face_data.fe_face_values_cell.reinit(cell, face_no);
    face_data.fe_face_values_cell.get_function_gradients(
            primal_solution, face_data.cell_grads);

    const unsigned int neighbor_neighbor =
            cell->neighbor_of_neighbor(face_no);
    //Then define an abbreviation for the neighbor cell, initialize the FEFaceValues object on that cell, and extract the gradients on that cell:

    const active_cell_iterator neighbor = cell->neighbor(face_no);
    face_data.fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor);
    face_data.fe_face_values_neighbor.get_function_gradients(
            primal_solution, face_data.neighbor_grads);

    //Now that we have the gradients on this and the neighboring cell, compute the jump residual by multiplying the jump in the gradient with the normal vector:

    for (unsigned int p = 0; p < n_q_points; ++p)
        face_data.jump_residual[p] =
                ((face_data.cell_grads[p] - face_data.neighbor_grads[p]) *
                 face_data.fe_face_values_cell.normal_vector(p));

    //Next get the dual weights for this face:

    face_data.fe_face_values_cell.get_function_values(dual_weights,
                                                      face_data.dual_weights);

    //Finally, we have to compute the sum over jump residuals, dual weights, and quadrature weights, to get the result for this face:

    double face_integral = 0;
    for (unsigned int p = 0; p < n_q_points; ++p)
        face_integral +=
                (face_data.jump_residual[p] * face_data.dual_weights[p] *
                 face_data.fe_face_values_cell.JxW(p));

    face_integrals[cell->face(face_no)] = face_integral;
}

template <int dim>
void ErrorController<dim>::integrate_over_irregular_face(
        const active_cell_iterator &cell,
        const unsigned int          face_no,
        const Vector<double> &      primal_solution,
        const Vector<double> &      dual_weights,
        FaceData &                  face_data,
        FaceIntegrals &             face_integrals) const
{
    //First again two abbreviations, and some consistency checks whether the function is called only on faces for which it is supposed to be called:

    const unsigned int n_q_points =
            face_data.fe_face_values_cell.n_quadrature_points;

    const typename DoFHandler<dim>::face_iterator face = cell->face(face_no);
    const typename DoFHandler<dim>::cell_iterator neighbor =
            cell->neighbor(face_no);
    //Assert(neighbor.state() == IteratorState::valid, ExcInternalError());
    //Assert(neighbor->has_children(), ExcInternalError());
    (void)neighbor;

    //Then find out which neighbor the present cell is of the adjacent cell. Note that we will operate on the children of this adjacent cell, but that their orientation is the same as that of their mother, i.e. the neighbor direction is the same.

    const unsigned int neighbor_neighbor =
            cell->neighbor_of_neighbor(face_no);

    //Then simply do everything we did in the previous function for one face for all the sub-faces now:

    for (unsigned int subface_no = 0; subface_no < face->n_children();
         ++subface_no)
    {
        //Start with some checks again: get an iterator pointing to the cell behind the present subface and check whether its face is a subface of the one we are considering. If that were not the case, then there would be either a bug in the neighbor_neighbor function called above, or – worse – some function in the library did not keep to some underlying assumptions about cells, their children, and their faces. In any case, even though this assertion should not be triggered, it does not harm to be cautious, and in optimized mode computations the assertion will be removed anyway.

        const active_cell_iterator neighbor_child =
                cell->neighbor_child_on_subface(face_no, subface_no);
        /*Assert(neighbor_child->face(neighbor_neighbor) ==
               cell->face(face_no)->child(subface_no),
               ExcInternalError());*/

        //Now start the work by again getting the gradient of the solution first at this side of the interface,

        face_data.fe_subface_values_cell.reinit(cell, face_no, subface_no);
        face_data.fe_subface_values_cell.get_function_gradients(
                primal_solution, face_data.cell_grads);
        //then at the other side,

        face_data.fe_face_values_neighbor.reinit(neighbor_child,
                                                 neighbor_neighbor);
        face_data.fe_face_values_neighbor.get_function_gradients(
                primal_solution, face_data.neighbor_grads);

        //and finally building the jump residuals. Since we take the normal vector from the other cell this time, revert the sign of the first term compared to the other function:

        for (unsigned int p = 0; p < n_q_points; ++p)
            face_data.jump_residual[p] =
                    ((face_data.neighbor_grads[p] - face_data.cell_grads[p]) *
                     face_data.fe_face_values_neighbor.normal_vector(p));

        //Then get dual weights:

        face_data.fe_face_values_neighbor.get_function_values(
                dual_weights, face_data.dual_weights);

        //At last, sum up the contribution of this sub-face, and set it in the global map:

        double face_integral = 0;
        for (unsigned int p = 0; p < n_q_points; ++p)
            face_integral +=
                    (face_data.jump_residual[p] * face_data.dual_weights[p] *
                     face_data.fe_face_values_neighbor.JxW(p));
        face_integrals[neighbor_child->face(neighbor_neighbor)] =
                face_integral;
    }

    //Once the contributions of all sub-faces are computed, loop over all sub-faces to collect and store them with the mother face for simple use when later collecting the error terms of cells. Again make safety checks that the entries for the sub-faces have been computed and do not carry an invalid value.

    double sum = 0;
    for (unsigned int subface_no = 0; subface_no < face->n_children();
         ++subface_no)
    {
        /*Assert(face_integrals.find(face->child(subface_no)) !=
               face_integrals.end(),
               ExcInternalError());
        Assert(face_integrals[face->child(subface_no)] != -1e20,
               ExcInternalError());*/

        sum += face_integrals[face->child(subface_no)];
    }
    //Finally store the value with the parent face.

            face_integrals[face] = sum;
}


template <int dim>
double ErrorController<dim>::global_estimate() const {
    // INTERPOLATION
    AffineConstraints<double> dual_hanging_node_constraints;
    DoFTools::make_hanging_node_constraints(DualSolver<dim>::dof_handler,
                                            dual_hanging_node_constraints);
    dual_hanging_node_constraints.close();
    Vector<double> primal_solution(DualSolver<dim>::dof_handler.n_dofs());
    cout<<"   [ErrorController::global_estimate]Interpolated primal solution DOF "<<primal_solution.size()<< endl;
    FETools::interpolate(PrimalSolver<dim>::dof_handler,
                         PrimalSolver<dim>::solution,
                         DualSolver<dim>::dof_handler,
                         dual_hanging_node_constraints,
                         primal_solution);

    AffineConstraints<double> primal_hanging_node_constraints;
    DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,
                                            primal_hanging_node_constraints);
    primal_hanging_node_constraints.close();
    Vector<double> dual_weights(DualSolver<dim>::dof_handler.n_dofs());
    FETools::interpolation_difference(DualSolver<dim>::dof_handler,
                                      dual_hanging_node_constraints,
                                      DualSolver<dim>::solution,
                                      PrimalSolver<dim>::dof_handler,
                                      primal_hanging_node_constraints,
                                      dual_weights);

    cout<<"   [ErrorController::global_estimate]Interpolations done"<<endl;

    // EVALUATION
    Vector<double> temp(dual_weights.size());
    double global_error = 0.0;
    DualSolver<dim>::system_matrix.vmult(temp,dual_weights);

    if(temp.size()!=primal_solution.size())
        cout<<"PROBLEMA DIMENSIONALE"<<endl;
    for(size_t i=0;i<primal_solution.size();++i)
        global_error+=primal_solution(i)*temp(i);
    return -global_error;
}

#endif //GETPOT_ERRORCONTROLLER_H