Ciao, ora il codice ha un aspetto diverso.
Non temere, ci sono solo due cose da sapere, poi è facilissimo.

---------------------------------------------------------------------
!!!! ---- !!!    Solo la prima volta	!!!! ---- !!!
---------------------------------------------------------------------
Posizionati nella root della cartella
> cd ion-propulsion
Crea i tuoi file di sistema di CMake con
> cmake -S . -B build
Significa: crea i file preendendo Source (CMakeLists.txt) in questa cartella,
ma salva tutti quei file ridondanti in ion-propulsion/build/

NB: Non dovrai mai più usare cmake
D'ora in poi solo make (nel dettaglio prossimo paragrafo)


---------------------------------
 ----    Everyday use	 ---- 
---------------------------------
D'ora in poi, per fare qualsiasi cosa,dovrai posizonarti nella subdirctory /build
> cd ion-propulsion/build

Da qui i principali comandi che ti servono sono:
> clear
(classico comando per fare un po' di pulizia dei muri di testo del terminale)
> make run
Per compilare ed eseguire. O anche solo per eseguire. I pc capisce da solo se ci sono differenze dall'ultima volta che hai compilato. Se non ne trova, farà solo l'esecuzione.
Insomma, questo comadno basta per fare tutto
> make cleanres
Svuota la cartella dei risultati
> make cleanmesh
Svuota la cartella dell'archivio delle mesh



---------------------------------
 ----    Cosa cambia	 ---- 
---------------------------------

0)
I risultati sono nella subdirectory /results
Non è necessario perchè vengono sovrascritti, ma se vuoi esser sicuro di generare file nuovi ad ogni esecuzione.
Lancia
> make cleanres
prima del "make run". Questo svuoterà suddetta cartella da .svg e .vtu


1)
Abbiamo lavorato sul tuo Mesh.cc e da lì siamo progrediti.
Abbiamo smembrato quel codice in diversi file.
I .cpp sono in /src, gli header (.h) sono in /include.
Questa struttura non è molto formale e potremmo cambiarla, ma quantomeno distingue bene le cose.

Differenza fra cpp e header:
Gli header non vanno compilati.
Ogni volta che una funzione viene chiamata il compilatore fa copia e incolla nel file oggetto (.o) che pian piano si sta costruendo.
Molto snelli.
Generalmente le classi o gli agglomerati di funzioni si definiscono con un'accoppiata header-cpp, rigorosamente con lo stesso nome: nell'header dichiari le funzioni, nel cpp le definisci.
Quando una classe ha le funzioni sia dichiarate sia definite nell'header, si dice che le ha definite "inline"


2)
Il parser:
QUalche volta leggerai GetPot, datafile, ecc..
Si tratta del parser, ossia include/GetPot, che permette di scrivere tutti i dati in un file di testo ("data_setup" per noi) e ripescarli nel codice.
Vantaggio: vuoi cambiuare un dato? Non devi impazzire per ricercare dove l'avevi impostato nei meandri delle funzioni.


3)
Gmsh:
Proprio negli ultimi giorni abbiamo abbandonato la creazione della mesh tramite HyperRectangle. Abbiamo persino abbandonato l'uso di SetManifoldAndBoundaries.
Infatti ci siamo appoggiati, per la creazione della mesh e per il setting dei boundary_ids all'app Gmsh (tutorial 49).
Ti faremonvedere di persona la magia.


4)
Save&load delle mesh:
Siccome i nostri pc non erano molto veloci, la prima preorgativa o stata quella di creare un sistema di slavatggio delle mesh, da poter ripescare in un run successivo, senza partire da zero.
Il codice fa quindi questo.
Quando chiami create_grid:
Controlla se in mesh_storage c'è una grid salvata
	- Sì:   Carica quella 
		Vai avanti con l'esecuzione
	- No:   In gmsh_grids c'è almeno quella base (non raffinata)?
		-- Sì	Carica quella
			Fai il raffinamento
			Salvala in mesh_storage
			Vai avanti con l'esecuzione
		-- No	Dai errore. Non puoi procedere senza la mesh di gmsh.

Per fare tutta la strada e testre la creazione della mesh, ricordati di fare 
> make cleanmesh
che svuolta mesh_storage.
Tranquillo, gmsh_grids non viene svuotata da quel codice. 
Non avrebbe senso, dato che sono le fondamenta su cui costruiamo le nostre mesh.


5) 
check_boundary_ids
È una funziona che crea un .vtu per guardare a posteriori se hai messo bene i boundary_ids.
La trovi in /results dopo aver runnato.
Consiglio di aprirla su: Paraview > Points > Points size = 10


6) 
Documenti
In /docs trovi un po' di schemini nostri, tra cui uno screen di gmsh con gli id dati ai vari lati.
Come avevi fatto tu:
1: emettitore
2: colelettore
3: Non verrà specificato nel codice, per ora dealii gli applica null-Neumann_BC


7)
Non guardare DirichletBoundaryConditionsDX.h
Nel codice non viene usato.
Serve per mettere BC personalizzate e non solo uniformi.
ma per ora non ci sono state utili





A giovedì, ciao!










Link utili:
---------------------------
Mini-tutorial su Visit: 
	https://youtu.be/3ChnUxqtt08
Wiki dealii:
	https://www.dealii.org/current/doxygen/deal.II/Tutorial.html



